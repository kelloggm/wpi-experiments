package org.plumelib.javadoc;

import static com.github.javaparser.utils.PositionUtils.sortByBeginPosition;

import com.github.javaparser.ParseProblemException;
import com.github.javaparser.Position;
import com.github.javaparser.Range;
import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.PackageDeclaration;
import com.github.javaparser.ast.body.AnnotationDeclaration;
import com.github.javaparser.ast.body.AnnotationMemberDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.EnumConstantDeclaration;
import com.github.javaparser.ast.body.EnumDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.comments.Comment;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.ThisExpr;
import com.github.javaparser.ast.expr.UnaryExpr;
import com.github.javaparser.ast.nodeTypes.NodeWithJavadoc;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.ReturnStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;
import org.plumelib.options.Options;

/**
 * A program that issues an error for any class, constructor, method, or field that lacks a Javadoc
 * comment. Does not issue a warning for methods annotated with {@code @Override}. See documentation
 * at <a
 * href="https://github.com/plume-lib/require-javadoc#readme">https://github.com/plume-lib/require-javadoc#readme</a>.
 */
@org.checkerframework.framework.qual.AnnotatedFor(
    "org.checkerframework.checker.calledmethods.CalledMethodsChecker")
public class RequireJavadoc {

  /** Matches name of file or directory where no problems should be reported. */
  public Pattern exclude = null;

  // TODO: It would be nice to support matching fully-qualified class names, but matching
  // packages will have to do for now.
  /**
   * Matches simple name of class/constructor/method/field, or full package name, where no problems
   * should be reported.
   */
  public Pattern dont_require = null;

  /** If true, don't check elements with private access. */
  public boolean dont_require_private;

  /**
   * If true, don't check constructors with zero formal parameters. These are sometimes called
   * "default constructors", though that term means a no-argument constructor that the compiler
   * synthesized when the programmer didn't write one.
   */
  public boolean dont_require_noarg_constructor;

  /**
   * If true, don't check trivial getters and setters.
   *
   * <p>Trivial getters and setters are of the form:
   *
   * <pre>{@code
   * Foo getFoo() {
   *   return this.foo;
   * }
   *
   * void setFoo(Foo foo) {
   *   this.foo = foo;
   * }
   *
   * boolean hasFoo() {
   *   return foo;
   * }
   *
   * boolean isFoo() {
   *   return foo;
   * }
   *
   * boolean notFoo() {
   *   return !foo;
   * }
   * }</pre>
   */
  public boolean dont_require_trivial_properties;

  /** If true, don't check type declarations: classes, interfaces, enums, annotations. */
  public boolean dont_require_type;

  /** If true, don't check fields. */
  public boolean dont_require_field;

  /** If true, don't check methods, constructors, and annotation members. */
  public boolean dont_require_method;

  /** If true, warn if any package lacks a package-info.java file. */
  public boolean require_package_info;

  /**
   * If true, print filenames relative to working directory. Setting this only has an effect if the
   * command-line arguments were absolute pathnames, or no command-line arguments were supplied.
   */
  public boolean relative = false;

  /** If true, output debug information. */
  public boolean verbose = false;

  /** All the errors this program will report. */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  List<String> errors = new ArrayList<>();

  /** The Java files to be checked. */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  List<Path> javaFiles = new ArrayList<Path>();

  /** The current working directory, for making relative pathnames. */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  Path workingDirRelative = Paths.get("");

  /** The current working directory, for making relative pathnames. */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  Path workingDirAbsolute = Paths.get("").toAbsolutePath();

  /**
   * The main entry point for the require-javadoc program. See documentation at <a
   * href="https://github.com/plume-lib/require-javadoc#readme">https://github.com/plume-lib/require-javadoc#readme</a>.
   *
   * @param args the command-line arguments; see the README file
   */
  public static void main(String[] args) {
    RequireJavadoc rj = new RequireJavadoc();
    Options options =
        new Options(
            "java org.plumelib.javadoc.RequireJavadoc [options] [directory-or-file ...]", rj);
    String[] remainingArgs = options.parse(true, args);
    rj.setJavaFiles(remainingArgs);
    for (Path javaFile : rj.javaFiles) {
      if (rj.verbose) {
        System.out.println("Checking " + javaFile);
      }
      try {
        CompilationUnit cu = StaticJavaParser.parse(javaFile);
        RequireJavadocVisitor visitor = rj.new RequireJavadocVisitor(javaFile);
        visitor.visit(cu, null);
      } catch (IOException e) {
        System.out.println("Problem while reading " + javaFile + ": " + e.getMessage());
        System.exit(2);
      } catch (ParseProblemException e) {
        System.out.println("Problem while parsing " + javaFile + ": " + e.getMessage());
        System.exit(2);
      }
    }
    for (String error : rj.errors) {
      System.out.println(error);
    }
    System.exit(rj.errors.isEmpty() ? 0 : 1);
  }

  /** Creates a new RequireJavadoc instance. */
  @org.checkerframework.dataflow.qual.SideEffectFree
  private RequireJavadoc() {}

  /**
   * Set the Java files to be processed from the command-line arguments.
   *
   * @param args the directories and files listed on the command line
   */
  @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
      value = {"this"},
      methods = {"shouldExclude"})
  private void setJavaFiles(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
          String @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] args) {
    if (args.length == 0) {
      args = new String[] {workingDirAbsolute.toString()};
    }
    FileVisitor<Path> walker = new JavaFilesVisitor();
    for (String arg : args) {
      if (shouldExclude(arg)) {
        continue;
      }
      Path p = Paths.get(arg);
      File f = p.toFile();
      if (!f.exists()) {
        System.out.println("File not found: " + f);
        System.exit(2);
      }
      if (f.isDirectory()) {
        try {
          Files.walkFileTree(p, walker);
        } catch (IOException e) {
          System.out.println("Problem while reading " + f + ": " + e.getMessage());
          System.exit(2);
        }
      } else {
        javaFiles.add(Paths.get(arg));
      }
    }
    javaFiles.sort(Comparator.comparing(Object::toString));
    Set<Path> missingPackageInfoFiles = new LinkedHashSet<>();
    if (require_package_info) {
      for (Path javaFile : javaFiles) {
        Path javaFileParent = javaFile.getParent();
        // Java 11 has Path.of() instead of creating a new File.
        Path packageInfo = javaFileParent.resolve(new File("package-info.java").toPath());
        if (!javaFiles.contains(packageInfo)) {
          missingPackageInfoFiles.add(packageInfo);
        }
      }
      for (Path packageInfo : missingPackageInfoFiles) {
        errors.add("missing package documentation: no file " + packageInfo);
      }
    }
  }

  /** Collects files into the {@link #javaFiles} variable. */
  private class JavaFilesVisitor extends SimpleFileVisitor<Path> {

    /** Create a new JavaFilesVisitor. */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"<init>"})
    JavaFilesVisitor() {}

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#2"},
        methods = {"isRegularFile"})
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldExclude"})
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileVisitResult
        visitFile(
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
                JavaFilesVisitor this,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path file,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
                BasicFileAttributes attr) {
      if (attr.isRegularFile() && file.toString().endsWith(".java")) {
        if (!shouldExclude(file)) {
          javaFiles.add(file);
        }
      }
      return FileVisitResult.CONTINUE;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#1"},
        methods = {"toString"})
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldExclude"})
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileVisitResult
        preVisitDirectory(
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
                JavaFilesVisitor this,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path dir,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
                BasicFileAttributes attr) {
      if (shouldExclude(dir)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }

    @org.checkerframework.framework.qual.EnsuresQualifier(
        expression = {"#2"},
        qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileVisitResult
        postVisitDirectory(
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
                JavaFilesVisitor this,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path dir,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) IOException exc) {
      if (exc != null) {
        System.out.println("Problem visiting " + dir + ": " + exc.getMessage());
        System.exit(2);
      }
      return FileVisitResult.CONTINUE;
    }

    @org.checkerframework.framework.qual.EnsuresQualifier(
        expression = {"#2"},
        qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileVisitResult
        visitFileFailed(
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
                JavaFilesVisitor this,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path file,
            @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) IOException exc) {
      if (exc != null) {
        System.out.println("Problem visiting " + file + ": " + exc.getMessage());
        System.exit(2);
      }
      return FileVisitResult.CONTINUE;
    }
  }

  /**
   * Return true if the given Java element should not be checked, based on the {@code
   * --dont-require} command-line argument.
   *
   * @param name the name of a Java element. It is a simple name, except for packages.
   * @return true if no warnings should be issued about the element
   */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  boolean shouldNotRequire(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String name) {
    if (dont_require == null) {
      return false;
    }
    boolean result = dont_require.matcher(name).find();
    if (verbose) {
      System.out.printf("shouldNotRequire(%s) => %s%n", name, result);
    }
    return result;
  }

  /**
   * Return true if the given file or directory should be skipped, based on the {@code --exclude}
   * command-line argument.
   *
   * @param fileName the name of a Java file or directory
   * @return true if the file or directory should be skipped
   */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  boolean shouldExclude(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String fileName) {
    if (exclude == null) {
      return false;
    }
    boolean result = exclude.matcher(fileName).find();
    if (verbose) {
      System.out.printf("shouldExclude(%s) => %s%n", fileName, result);
    }
    return result;
  }

  /**
   * Return true if the given file or directory should be skipped, based on the {@code --exclude}
   * command-line argument.
   *
   * @param path a Java file or directory
   * @return true if the file or directory should be skipped
   */
  @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
      value = {"#1"},
      methods = {"toString"})
  @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
      value = {"this"},
      methods = {"shouldExclude"})
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  boolean shouldExclude(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path path) {
    return shouldExclude(path.toString());
  }

  /** The type of property method: a getter or setter. */
  enum PropertyType {

    /** A method of the form {@code int getFoo()}. */
    GETTER("get", 0, false),
    /** A method of the form {@code boolean hasFoo()}. */
    GETTER_HAS("has", 0, false),
    /** A method of the form {@code boolean isFoo()}. */
    GETTER_IS("is", 0, false),
    /** A method of the form {@code boolean notFoo()}. */
    GETTER_NOT("not", 0, false),
    /** A method of the form {@code void setFoo(int arg)}. */
    SETTER("set", 1, true);

    /** The prefix for the method name: "get", "has", "is", "not", or "set". */
    final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String prefix;

    /** The number of required formal parameters: 0 or 1. */
    final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int requiredParams;

    /** Whether the return type is void. */
    final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean voidReturn;

    /**
     * Create a new PropertyType.
     *
     * @param prefix the prefix for the method name: "get", "has", "is", "not", or "set"
     * @param requiredParams the number of required formal parameters: 0 or 1
     * @param voidReturn whether the return type is void
     */
    PropertyType(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String prefix,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int requiredParams,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean voidReturn) {
      this.prefix = prefix;
      this.requiredParams = requiredParams;
      this.voidReturn = voidReturn;
    }
  }

  /**
   * Return true if this method declaration is a trivial getter or setter.
   *
   * <ul>
   *   <li>A trivial getter is named "getFoo", "hasFoo", "isFoo", or "notFoo", has no formal
   *       parameters, and has a body of the form "return foo" or "return this.foo" (except for
   *       "notFoo", in which case the body is negated).
   *   <li>A trivial setter is named "setFoo", has one formal parameter named "foo", and has a body
   *       of the form "this.foo = foo".
   * </ul>
   *
   * @param md the method to check
   * @return true if this method is a trivial getter on setter
   */
  @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
      value = {"#1"},
      methods = {"getNameAsString"})
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  boolean isTrivialGetterOrSetter(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MethodDeclaration md) {
    String methodName = md.getNameAsString();
    if (methodName.startsWith("get")
        || methodName.startsWith("has")
        || methodName.startsWith("is")
        || methodName.startsWith("not")) {
      PropertyType getterType =
          methodName.startsWith("get")
              ? PropertyType.GETTER
              : methodName.startsWith("has")
                  ? PropertyType.GETTER_HAS
                  : methodName.startsWith("is") ? PropertyType.GETTER_IS : PropertyType.GETTER_NOT;
      String propertyName = propertyName(md, getterType);
      if (propertyName == null) {
        return false;
      }
      if (getterType == PropertyType.GETTER_HAS
          || getterType == PropertyType.GETTER_IS
          || getterType == PropertyType.GETTER_NOT) {
        if (!md.getType().toString().equals("boolean")) {
          return false;
        }
      }
      Statement statement = getOnlyStatement(md);
      if (!(statement instanceof ReturnStmt)) {
        return false;
      }
      Optional<Expression> oReturnExpr = ((ReturnStmt) statement).getExpression();
      if (!oReturnExpr.isPresent()) {
        return false;
      }
      Expression returnExpr = oReturnExpr.get();
      // Does not handle parentheses.
      if (getterType == PropertyType.GETTER_NOT) {
        if (!(returnExpr instanceof UnaryExpr)) {
          return false;
        }
        UnaryExpr unary = (UnaryExpr) returnExpr;
        if (unary.getOperator() != UnaryExpr.Operator.LOGICAL_COMPLEMENT) {
          return false;
        }
        returnExpr = unary.getExpression();
      }
      String returnName;
      if (returnExpr instanceof NameExpr) {
        returnName = ((NameExpr) returnExpr).getNameAsString();
      } else if (returnExpr instanceof FieldAccessExpr) {
        FieldAccessExpr fa = (FieldAccessExpr) returnExpr;
        Expression receiver = fa.getScope();
        if (!(receiver instanceof ThisExpr)) {
          return false;
        }
        returnName = fa.getNameAsString();
      } else {
        return false;
      }
      if (!returnName.equals(propertyName)) {
        return false;
      }
      return true;
    } else if (methodName.startsWith("set")) {
      String propertyName = propertyName(md, PropertyType.SETTER);
      if (propertyName == null) {
        return false;
      }
      Statement statement = getOnlyStatement(md);
      if (!(statement instanceof ExpressionStmt)) {
        return false;
      }
      Expression expr = ((ExpressionStmt) statement).getExpression();
      if (!(expr instanceof AssignExpr)) {
        return false;
      }
      AssignExpr assignExpr = (AssignExpr) expr;
      Expression target = assignExpr.getTarget();
      AssignExpr.Operator op = assignExpr.getOperator();
      Expression value = assignExpr.getValue();
      if (!(target instanceof FieldAccessExpr)) {
        return false;
      }
      FieldAccessExpr fa = (FieldAccessExpr) target;
      Expression receiver = fa.getScope();
      if (!(receiver instanceof ThisExpr)) {
        return false;
      }
      if (!fa.getNameAsString().equals(propertyName)) {
        return false;
      }
      if (op != AssignExpr.Operator.ASSIGN) {
        return false;
      }
      if (!(value instanceof NameExpr
          && ((NameExpr) value).getNameAsString().equals(propertyName))) {
        return false;
      }
      return true;
    }
    return false;
  }

  /**
   * Returns the name of the property with initial letter in lower case, if the method is a getter
   * or setter. Otherwise returns null.
   *
   * <p>Examines the method's name and signature, but not its body.
   *
   * @param md the method to test
   * @param propertyType the type of property method
   * @return the lower-cased name of the property, or null
   */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  String propertyName(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({"getNameAsString"})
          MethodDeclaration md,
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
          PropertyType propertyType) {
    String methodName = md.getNameAsString();
    if (!methodName.startsWith(propertyType.prefix)) {
      return null;
    }
    String upperCamelCaseProperty = methodName.substring(propertyType.prefix.length());
    if (upperCamelCaseProperty.length() == 0) {
      return null;
    }
    if (!Character.isUpperCase(upperCamelCaseProperty.charAt(0))) {
      return null;
    }
    String lowerCamelCaseProperty =
        ""
            + Character.toLowerCase(upperCamelCaseProperty.charAt(0))
            + upperCamelCaseProperty.substring(1);
    NodeList<Parameter> parameters = md.getParameters();
    if (parameters.size() != propertyType.requiredParams) {
      return null;
    }
    if (parameters.size() == 1) {
      Parameter parameter = parameters.get(0);
      if (!parameter.getNameAsString().equals(lowerCamelCaseProperty)) {
        return null;
      }
    }
    // Check presence/absence of return type. (The Java compiler will verify
    // that the type is correct, except that "isFoo()" and "notFoo()" accessors
    // should have boolean return type, which is verified elsewhere.)
    Type returnType = md.getType();
    if (propertyType.voidReturn != returnType.isVoidType()) {
      return null;
    }
    return lowerCamelCaseProperty;
  }

  /**
   * If the body contains exactly one statement, returns it. Otherwise, returns null.
   *
   * @param md a method declaration
   * @return its sole statement, or null
   */
  @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
      value = {"#1"},
      methods = {"getNameAsString", "getBody"})
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  Statement getOnlyStatement(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({"getNameAsString"})
          MethodDeclaration md) {
    Optional<BlockStmt> body = md.getBody();
    if (!body.isPresent()) {
      return null;
    }
    NodeList<Statement> statements = body.get().getStatements();
    if (statements.size() != 1) {
      return null;
    }
    return statements.get(0);
  }

  /** Visits an AST and collects warnings about missing Javadoc. */
  private class RequireJavadocVisitor extends VoidVisitorAdapter<Void> {

    /** The file being visited. Used for constructing error messages. */
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
    Path filename;

    /**
     * Create a new RequireJavadocVisitor.
     *
     * @param filename the file being visited; used for diagnostic messages
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"<init>"})
    RequireJavadocVisitor(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path filename) {
      this.filename = filename;
    }

    /**
     * Return a string stating that documentation is missing on the given construct.
     *
     * @param node a Java language construct (class, constructor, method, field, etc.)
     * @param simpleName the construct's simple name, used in diagnostic messages
     * @return an error message for the given construct
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#1"},
        methods = {"getRange"})
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String errorString(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Node node,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String simpleName) {
      Optional<Range> range = node.getRange();
      if (range.isPresent()) {
        Position begin = range.get().begin;
        Path path =
            (relative
                ? (filename.isAbsolute() ? workingDirAbsolute : workingDirRelative)
                    .relativize(filename)
                : filename);
        return String.format(
            "%s:%d:%d: missing documentation for %s", path, begin.line, begin.column, simpleName);
      } else {
        return "missing documentation for " + simpleName;
      }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#1"},
        methods = {"getPackageDeclaration"})
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CompilationUnit cu,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      Optional<PackageDeclaration> opd = cu.getPackageDeclaration();
      if (opd.isPresent()) {
        String packageName = opd.get().getName().asString();
        if (shouldNotRequire(packageName)) {
          return;
        }
        Optional<String> oTypeName = cu.getPrimaryTypeName();
        if (oTypeName.isPresent()
            && oTypeName.get().equals("package-info")
            && !hasJavadocComment(opd.get())
            && !hasJavadocComment(cu)) {
          errors.add(errorString(opd.get(), packageName));
        }
      }
      if (verbose) {
        System.out.printf("Visiting compilation unit%n");
      }
      super.visit(cu, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            ClassOrInterfaceDeclaration cd,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      if (dont_require_private && cd.isPrivate()) {
        return;
      }
      String name = cd.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting type %s%n", name);
      }
      if (!dont_require_type && !hasJavadocComment(cd)) {
        errors.add(errorString(cd, name));
      }
      super.visit(cd, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            ConstructorDeclaration cd,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      if (dont_require_private && cd.isPrivate()) {
        return;
      }
      if (dont_require_noarg_constructor && cd.getParameters().size() == 0) {
        return;
      }
      String name = cd.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting constructor %s%n", name);
      }
      if (!dont_require_method && !hasJavadocComment(cd)) {
        errors.add(errorString(cd, name));
      }
      super.visit(cd, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"isTrivialGetterOrSetter"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MethodDeclaration md,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      if (dont_require_private && md.isPrivate()) {
        return;
      }
      if (dont_require_trivial_properties && isTrivialGetterOrSetter(md)) {
        if (verbose) {
          System.out.printf("skipping trivial property method %s%n", md.getNameAsString());
        }
        return;
      }
      String name = md.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting method %s%n", md.getName());
      }
      if (!dont_require_method && !isOverride(md) && !hasJavadocComment(md)) {
        errors.add(errorString(md, name));
      }
      super.visit(md, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"hasJavadocComment"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldDeclaration fd,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      if (dont_require_private && fd.isPrivate()) {
        return;
      }
      // True if shouldNotRequire is false for at least one of the fields
      boolean shouldRequire = false;
      if (verbose) {
        System.out.printf("Visiting field %s%n", fd.getVariables().get(0).getName());
      }
      boolean hasJavadocComment = hasJavadocComment(fd);
      for (VariableDeclarator vd : fd.getVariables()) {
        String name = vd.getNameAsString();
        // TODO: Also check the type of the serialVersionUID variable.
        if (name.equals("serialVersionUID")) {
          continue;
        }
        if (shouldNotRequire(name)) {
          continue;
        }
        shouldRequire = true;
        if (!dont_require_field && !hasJavadocComment) {
          errors.add(errorString(vd, name));
        }
      }
      if (shouldRequire) {
        super.visit(fd, ignore);
      }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) EnumDeclaration ed,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      if (dont_require_private && ed.isPrivate()) {
        return;
      }
      String name = ed.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting enum %s%n", name);
      }
      if (!dont_require_type && !hasJavadocComment(ed)) {
        errors.add(errorString(ed, name));
      }
      super.visit(ed, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#1"},
        methods = {"getNameAsString"})
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            EnumConstantDeclaration ecd,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      String name = ecd.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting enum constant %s%n", name);
      }
      if (!dont_require_field && !hasJavadocComment(ecd)) {
        errors.add(errorString(ecd, name));
      }
      super.visit(ecd, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AnnotationDeclaration ad,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      if (dont_require_private && ad.isPrivate()) {
        return;
      }
      String name = ad.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting annotation %s%n", name);
      }
      if (!dont_require_type && !hasJavadocComment(ad)) {
        errors.add(errorString(ad, name));
      }
      super.visit(ad, ignore);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#1"},
        methods = {"getNameAsString"})
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"this"},
        methods = {"shouldNotRequire"})
    public void visit(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            RequireJavadocVisitor this,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
            AnnotationMemberDeclaration amd,
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void ignore) {
      String name = amd.getNameAsString();
      if (shouldNotRequire(name)) {
        return;
      }
      if (verbose) {
        System.out.printf("Visiting annotation member %s%n", name);
      }
      if (!dont_require_method && !hasJavadocComment(amd)) {
        errors.add(errorString(amd, name));
      }
      super.visit(amd, ignore);
    }

    /**
     * Return true if this method is annotated with {@code @Override}.
     *
     * @param md the method to check for an {@code @Override} annotation
     * @return true if this method is annotated with {@code @Override}
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(
        value = {"#1"},
        methods = {"getNameAsString", "getAnnotations"})
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isOverride(
        @org.checkerframework.checker.calledmethods.qual.CalledMethods({"getNameAsString"})
            MethodDeclaration md) {
      for (AnnotationExpr anno : md.getAnnotations()) {
        String annoName = anno.getName().toString();
        if (annoName.equals("Override") || annoName.equals("java.lang.Override")) {
          return true;
        }
      }
      return false;
    }
  }

  /**
   * Return true if this node has a Javadoc comment.
   *
   * @param n the node to check for a Javadoc comment
   * @return true if this node has a Javadoc comment
   */
  @org.checkerframework.checker.calledmethods.qual.CalledMethods({})
  boolean hasJavadocComment(
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Node n) {
    if (n instanceof NodeWithJavadoc && ((NodeWithJavadoc<?>) n).hasJavaDocComment()) {
      return true;
    }
    List<Comment> orphans = new ArrayList<>();
    getOrphanCommentsBeforeThisChildNode(n, orphans);
    for (Comment orphan : orphans) {
      if (orphan.isJavadocComment()) {
        return true;
      }
    }
    Optional<Comment> oc = n.getComment();
    if (oc.isPresent()
        && (oc.get().isJavadocComment() || oc.get().getContent().startsWith("/**"))) {
      return true;
    }
    return false;
  }

  /**
   * Get "orphan comments": comments before the comment before this node. For example, in
   *
   * <pre>{@code
   * /** ... *}{@code /
   * // text 1
   * // text 2
   * void m() { ... }
   * }</pre>
   *
   * the Javadoc comment and {@code // text 1} are an orphan comment, and only {@code // text2} is
   * associated with the method.
   *
   * @param node the node whose orphan comments to collect
   * @param result the list to add orphan comments to. Is side-effected by this method. The
   *     implementation uses this to minimize the diffs against upstream.
   */
  private static // to provide such functionality in JavaParser proper.
  void getOrphanCommentsBeforeThisChildNode(
      final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Node node,
      @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<Comment> result) {
    if (node instanceof Comment) {
      return;
    }
    Node parent = node.getParentNode().orElse(null);
    if (parent == null) {
      return;
    }
    List<Node> everything = new LinkedList<>(parent.getChildNodes());
    sortByBeginPosition(everything);
    int positionOfTheChild = -1;
    for (int i = 0; i < everything.size(); i++) {
      if (everything.get(i) == node) positionOfTheChild = i;
    }
    if (positionOfTheChild == -1) {
      throw new AssertionError("I am not a child of my parent.");
    }
    int positionOfPreviousChild = -1;
    for (int i = positionOfTheChild - 1; i >= 0 && positionOfPreviousChild == -1; i--) {
      if (!(everything.get(i) instanceof Comment)) positionOfPreviousChild = i;
    }
    for (int i = positionOfPreviousChild + 1; i < positionOfTheChild; i++) {
      Node nodeToPrint = everything.get(i);
      if (!(nodeToPrint instanceof Comment))
        throw new RuntimeException(
            "Expected comment, instead "
                + nodeToPrint.getClass()
                + ". Position of previous child: "
                + positionOfPreviousChild
                + ", position of child "
                + positionOfTheChild);
      result.add((Comment) nodeToPrint);
    }
  }
}
